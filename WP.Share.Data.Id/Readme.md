## 背景

目前的数据库也好，业务号、流水号、随机号等都是零散的，就像数据库，采用自增后，一旦日后涉及到了数据库的合并，那简直是灾难，而且在数据库迁移中也会面临很多没法避开的坑。

## 需求分析

提供对公司内部可以全局管理、全局唯一、易于使用、高性能、可追溯的Id生成。

根据场景如下

+ 中心发号
+ 单机发号

## 解决方案

使用基于`snowflake`算法，根据公司业务特点，初步采用如下

识别号长度为64位，对应c#数据类型为有符号长整型 long，各数据结构如下

字段名 |  备注 | 作用
---|--- | ---
Sign|协议号 | 
WorkNode |工作号 | 
Timestamp  | 时间戳 | 
Sequence  |随机数 |


### 结构划分分析

对于协议号和随机数，毋庸置疑的是工作号和随机数是一前一后，唯一需要考虑的是工作号和时间戳的排序问题。

选择是时间戳放在工作号前面

为了考虑到日后大数据分析，海量数据聚合，降低集群数据的索引损耗，采用时间戳在工作号前面。而且更多的查询排序都是基于时间的。

### 结构细节确定

时间戳的基准时间为格林威治时间2018年01月01日00时00分00秒到生成时候的时间差（秒）

因为中心发号和单机发号的使用场景的不同，中心发号的发号机将会远远的少于单机发号

目前分配如下

+ 中心发号 sign 1
+ 单机发号 sign 2

#### 中心发号参数如下

字段名 | 字段长度 |数量 | 备注
---|---| ---|---
Sign|4 |16| 协议号
Timestamp | 32 | 136.2年 | 时间戳
WorkNode | 12 | 4096 |工作号
Sequence | 16| 65536 |随机数

内部通过http请求或者服务引用的方式获取，具体性能结果，测试后附上

#### 单机发号参数如下

字段名 | 字段长度 |数量 | 备注
---|---| ---|---
Sign|4 |16| 协议号
Timestamp | 32 | 136.2年 | 时间戳
WorkNode | 16 | 65536 |工作号
Sequence | 12 | 4096 |随机数

发号参数早期采用人工维护，后期对接自动审批维护。